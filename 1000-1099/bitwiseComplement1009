class Solution {
    public  int bitwiseComplement(int num) {
        // 因为 0 的二进制表示里一个1也没有，所以要特殊处理
        if (num == 0) {
            return 1;
        };

        // 最终得到的 highMask 是从 num 的第1个为1（不为0）的位置开始，后面全都是1; highMask 只和num最左侧的1的位置有关
        // 例如：假设 num是557056， 二进制表示为： 00001000 10000000 00000000 00000000
        int highMask =  num;
        // 得到num左边第1个为1的位置和右侧相邻位连续为1 (1个 + 1个), 得到： 00001100 11000000 00000000 00000000
        highMask |= highMask >> 1;
        // 得到num从左侧第1个1开始，连续4个1 （2个 + 2个），得到：00001111 11110000 00000000 00000000
        highMask |= highMask >> 2;
        // 得到num从左侧第1个1开始，连续8个1（4个 + 4个）, 得到： 00001111 11111111 00000000 00000000
        highMask |= highMask >> 4;
        // 得到num从左侧第1个1开始，得到连续16个1, 得到：        00001111 11111111 11111111 00000000
        highMask |= highMask >> 8;
        // 得到num从左侧第1个1开始，得到连续32个1(可能由于位数不够不到32个), 得到： 00001111 11111111 11111111 11111111

        highMask |= highMask >> 16;
        // 即最终得到的 highMask 是从 num 的第1个为1（不为0）的位置开始，后面全都是1; highMask 只和num最左侧的1的位置有关
        // num取反后，截取出有效的位数；即把多出来的前面的无效位通过highMask求与置为0，只留下后面的有效位
        return num ^ highMask;
    }
}
